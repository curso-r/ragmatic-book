{
    "collab_server" : "",
    "contents" : "# Transformação de dados\n\nA transformação de dados é uma tarefa usualmente dolorosa e demorada, podendo tomar a maior parte do tempo da análise. No entanto, como nosso interesse geralmente é na modelagem dos dados, essa tarefa é muitas vezes negligenciada.\n\n> \"(...) The fact that data science exists as a field is a colossal failure of statistics. To me, [what I do] is what statistics is all about. It is gaining insight from data using modelling and visualization. Data munging and manipulation is hard and statistics has just said that’s not our domain.\"\n> \n> Hadley Wickham\n\n## Pacotes `dplyr` e `tidyr`\n\nO `dplyr` é um dos pacotes mais úteis para realizar manipulação de dados, e procura aliar simplicidade e eficiência de uma forma bastante elegante. Os scripts em `R` que fazem uso inteligente dos verbos `dplyr` e as facilidades do operador _pipe_ tendem a ficar mais legíveis e organizados, sem perder velocidade de execução.\n\nPor ser um pacote que se propõe a realizar um dos trabalhos mais árduos da análise estatística, e por atingir esse objetivo de forma elegante, eficaz e eficiente, o `dplyr` pode ser considerado  como uma revolução no `R`.\n\n### Trabalhando com `tibble`s\n\nA `tibble` nada mais é do que um `data.frame`, mas com um método de impressão mais adequado. Outras diferenças podem ser estudadas [neste link](http://r4ds.had.co.nz/tibbles.html).\n\nVamos assumir que temos a seguinte base de dados:\n\n```{r echo=FALSE, warning=FALSE, message=FALSE}\nlibrary(dplyr)\nlibrary(stringr)\nd_cjsg <- readRDS('data/d_cjsg.rds')\n```\n\n```{r}\nd_cjsg\n```\n\n### As cinco funções principais do `dplyr`\n\n- `filter`\n- `mutate`\n- `select`\n- `arrange`\n- `summarise`\n\n### Características\n\n- O _input_  é sempre uma `tibble`, e o _output_  é sempre um `tibble`.\n- No primeiro argumento colocamos o `tibble`, e nos outros argumentos colocamo o que queremos fazer.\n- A utilização é facilitada com o emprego do operador `%>%`\n\n### Vantagens\n\n- Utiliza `C` e `C++` por trás da maioria das funções, o que geralmente torna o código mais eficiente.\n- Pode trabalhar com diferentes fontes de dados, como bases relacionais (SQL) e `data.table`.\n\n### `select`\n\n- Utilizar `starts_with(x)`, `contains(x)`, `matches(x)`, `one_of(x)`, etc.\n- Possível colocar nomes, índices, e intervalos de variáveis com `:`.\n\n```{r}\nd_cjsg %>% \n  select(id, cd_acordao, comarca, relator = relatora)\n```\n\n```{r}\nd_cjsg %>% \n  select(cd_acordao:comarca, classe_assunto)\n```\n\n```{r}\nd_cjsg %>% \n  select(n_processo, starts_with('data_'))\n```\n\n### `filter`\n\n- Parecido com `subset`.\n- Condições separadas por vírgulas é o mesmo que separar por `&`.\n\n```{r}\nd_cjsg %>% \n  select(id, cd_acordao, comarca, relator = relatora) %>% \n  filter(comarca == 'São Paulo')\n```\n\n```{r}\nlibrary(lubridate)\nd_cjsg %>% \n  select(id, cd_acordao, comarca, data_julgamento, relator = relatora) %>% \n  filter(comarca %in% c('Campinas', 'Sorocaba') &\n         (day(dmy(data_julgamento)) >= 29 | day(dmy(data_julgamento)) < 25))\n\nd_cjsg %>% \n  select(comarca) %>% \n  filter(str_detect(comarca, '^[gG]'))\n```\n\n### `mutate`\n\n- Parecido com `transform`, mas aceita várias novas colunas iterativamente.\n- Novas variáveis devem ter o mesmo `length` que o `nrow` do bd oridinal ou `1`.\n\n```{r}\nlibrary(stringr)\nd_cjsg %>% \n  select(id, n_processo, data_julgamento) %>% \n  mutate(ano_julgamento = year(dmy(data_julgamento)),\n         ano_proc = str_sub(n_processo, 12, 15),\n         ano_proc = as.numeric(ano_proc),\n         tempo_anos = ano_julgamento - ano_proc)\n```\n\n### `arrange`\n\n- Simplesmente ordena de acordo com as opções.\n- Utilizar `desc` para ordem decrescente.\n\n```{r}\nlibrary(stringr)\nd_cjsg %>% \n  select(id, n_processo, data_julgamento) %>% \n  mutate(ano_julgamento = year(dmy(data_julgamento)),\n         ano_proc = str_sub(n_processo, 12, 15),\n         ano_proc = as.numeric(ano_proc)) %>% \n  mutate(tempo_anos = ano_julgamento - ano_proc) %>% \n  arrange(desc(tempo_anos))\n```\n\n### `summarise`\n\n- Retorna um vetor de tamanho `1` a partir de uma conta com as variáveis.\n- Geralmente é utilizado em conjunto com `group_by`.\n- Algumas funções importantes: `n()`, `n_distinct()`.\n\n```{r}\nd_cjsg %>% \n  select(id, n_processo, comarca, data_julgamento, orgao_julgador) %>% \n  mutate(ano_julgamento = year(dmy(data_julgamento)),\n         ano_proc = str_sub(n_processo, 12, 15),\n         ano_proc = as.numeric(ano_proc)) %>% \n  mutate(tempo_anos = ano_julgamento - ano_proc) %>% \n  arrange(desc(tempo_anos)) %>% \n  group_by(comarca, orgao_julgador) %>% \n  summarise(n = n(),\n            media_anos = mean(tempo_anos),\n            min_anos = min(tempo_anos),\n            max_anos = max(tempo_anos)) %>% \n  filter(n > 5) %>% \n  arrange(desc(media_anos))\n```\n\n```{r}\nd_cjsg %>% \n  count(relatora, sort = TRUE) %>% \n  mutate(prop = n / sum(n), prop = scales::percent(prop))\n```\n\n### `gather`\n\n- \"Empilha\" o banco de dados\n\n```{r warning=FALSE, message=FALSE}\nlibrary(tidyr)\nd_cjsg %>% \n  select(cd_acordao:data_registro) %>% \n  gather(key, value, -cd_acordao) %>% \n  arrange(cd_acordao)\n```\n\n### `spread`\n\n- \"Joga\" uma variável nas colunas\n- É essencialmente a função inversa de `gather`\n\n```{r}\nd_cjsg %>% \n  distinct(cd_acordao, .keep_all = TRUE) %>% \n  select(cd_acordao:data_registro) %>% \n  gather(key, value, -cd_acordao) %>% \n  spread(key, value)\n```\n\n### Funções auxiliares\n\n- `unite` junta duas ou mais colunas usando algum separador (`_`, por exemplo).\n- `separate` faz o inverso de `unite`, e uma coluna em várias usando um separador.\n\n```{r}\nd_cjsg %>% \n  select(n_processo, classe_assunto) %>% \n  separate(classe_assunto, c('classe', 'assunto'), sep = ' / ', \n           extra = 'merge', fill = 'right') %>% \n  count(assunto, sort = TRUE)\n```\n\n### Um pouco mais de transformação de dados\n\n- Para juntar tabelas, usar `inner_join`, `left_join`, `anti_join`, etc.\n- Para realizar operações mais gerais, usar `do`.\n- Para retirar duplicatas, utilizar `distinct`.\n\n",
    "created" : 1475565903436.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2451544490",
    "id" : "395E8A5F",
    "lastKnownWriteTime" : 1475565910,
    "last_content_update" : 1475565910112,
    "path" : "~/Projects/ragmatic-book/05-transform.Rmd",
    "project_path" : "05-transform.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}